#+property: header-args :wrap src text
#+property: header-args:text :eval never

* Attribute Exploration

We want to describe the facilities ~conexp-clj~ is offering for attribute
exploration.  For this, let us start with a simple example context:

#+begin_src clojure :exports both
(def ctx (make-context 	#{"Crow" "Cod"} 
			#{"V" "C" "B" "E" "W" "F"} 
			#{["Crow" "V"] ["Crow" "C"] ["Crow" "B"] ["Crow" "E"] ["crow" "W"] ["Crow" "F"]
                          ["Cod" "V"] ["Cod" "E"]}))
ctx
#+end_src

For convenience the attributes are abbreviations of "Vertebrate", "Can Fly", "Beak", "Lays Eggs", "Warm-blooded" and "Feathers", in order.

#+RESULTS:
#+begin_src text

     |B C E F V W 
-----+------------
Cod  |. . x . x . 
Crow |x x x x x . 
#+end_src

To explore a context without any other features, just call
~explore-attributes~ with the corresponding context as its only
argument:

#+begin_src clojure :eval never
(explore-attributes :context ctx)
#+end_src

Exploration now proceeds as follows:

#+begin_src text
user=> (explore-attributes :context ctx)
Does the implication (#{} ⟶  #{E V}) hold? no
counterexample> object
Please enter new object: Crab
counterexample> attributes
Please enter the attributes the new object should have: "E"
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{} ⟶  #{E}) hold? no
counterexample> object
Please enter new object: Tiger
counterexample> attributes
Please enter the attributes the new object should have: "V" "W"
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{W} ⟶  #{V}) hold? yes

Does the implication (#{B} ⟶  #{E C F V}) hold? no
counterexample> object
Please enter new object: Ostrich
counterexample> attributes
Please enter the attributes the new object should have: "B" "E" "F" "V" "W"
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{B} ⟶  #{E F V}) hold? no
counterexample> object
Please enter new object: Platypus
counterexample> attributes
Please enter the attributes the new object should have: "B" "E" "V" "W"
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{B} ⟶  #{E V}) hold? no
counterexample> object
Please enter new object: Octopus
counterexample> attributes
Please enter the attributes the new object should have: "B" "E" 
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{B} ⟶  #{E}) hold? yes

Does the implication (#{F} ⟶  #{E B V}) hold? no
counterexample> object
Please enter new object: Velociraptor
counterexample> attributes
Please enter the attributes the new object should have: "E" "F" "V"
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{F} ⟶  #{E V}) hold? yes

Does the implication (#{C} ⟶  #{E F B V}) hold? no
counterexample> object
Please enter new object: Bat
counterexample> attributes
Please enter the attributes the new object should have: "C" "V" "W"
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{C} ⟶  #{V}) hold? no
counterexample> object
Please enter new object: Dragonfly
counterexample> attributes
Please enter the attributes the new object should have: "C" "E"
counterexample> q
Do you want to give another counterexample? no

Does the implication (#{E V W} ⟶  #{B}) hold? yes

Does the implication (#{E C V} ⟶  #{F B}) hold? yes

Does the implication (#{E C B} ⟶  #{F V}) hold? yes

{:implications
 #{(#{"E" "C" "B"} ⟶  #{"F" "V"}) (#{"W"} ⟶  #{"V"})
   (#{"B"} ⟶  #{"E"}) (#{"E" "C" "V"} ⟶  #{"F" "B"})
   (#{"E" "V" "W"} ⟶  #{"B"}) (#{"F"} ⟶  #{"E" "V"})},
 :context              
	     |B C E F V W 
-------------+------------
Bat          |. x . . x x 
Crab         |. . x . . . 
Dragonfly    |. x x . . . 
Octopus      |x . x . . . 
Ostrich      |x . x x x x 
Platypus     |x . x . x x 
Tiger        |. . . . x x 
Velociraptor |. . x x x . 
Cod          |. . x . x . 
Crow         |x x x x x . 
}

user=>
#+end_src

The result returned by ~explore-attributes~ is a hash-map with the implications
found, together with the resulting context.

You can enter ~help~ to get a list of all available inputs:

#+begin_src clojure :exports both
Type «abort» to abort exploration.
Any other command can be abbreviated, as long as this is unambigious.
  complete-example
    -> Adds all attributes, which are not positive, to the negatives.
  saturate-partial-example
    -> Saturates the given partial counterexample.
  help
    -> Prints help prompt.
  quit
    -> Quit the REPL, if the given counterexample is valid.
  attributes
    -> Enter all attributes the object has.
  object
    -> Enter a name for the new object.
  clear
    -> Clears the current state.
  knowledge
    -> Prints the currently known implications (including background knowledge).
  positives
    -> Give some attributes the object definitively has.
  done
    -> Alias for «quit»
  implication
    -> Prints the current implication.
  state
    -> Prints the current state.
  check-counterexample
    -> Checks the given counterexample for being valid.
  negatives
    -> Give some attributes the object definitively has not.
  context
    -> Prints the current context.
#+end_src

You can also type ~abort~ to cancel the exploration.

It is also possible to add background knowledge to the exploration. Just give,
as second argument, a set of valid implications.  This may short cut some steps
of the exploration, up to the point that no interaction is required:

#+begin_src clojure :exports both
(explore-attributes
  :context ctx
  :background-knowledge #{(make-implication #{3} #{1})})
#+end_src

#+RESULTS:
#+begin_src text
{:implications #{}, :context   |1 2 3 
--+------
a |. x . 
b |x x . 
c |x . x 
}
#+end_src

Note that the given background knowledge is not part of the returned
implications.

Finally, you can control the way the exploration handles interaction with a
custom handler function. This functions is called whenever an expert has to be
asked, getting as its arguments the current context, all heretofore known
implications and the current implication. Standardly, the function
~default-handler~ is used, which implements low level communication via the
command line.

Handlers have to return specific values to indicate approval or rejection of a
given implication. The format of the return value is as follows:

- On success: ~nil~
- On failure: sequence of [«a new object» «a sequence of its attributes»]

You can think of a handler as a function providing counterexamples to a given
implication.  If no counterexample is returned, the implication is assumed to be
correct.

With that, you could easily immitate ~canonical-base~ with ~explore-attributes~:

#+begin_src clojure :exports both
(equivalent-implications?
  (:implications (explore-attributes :context ctx :handler (constantly nil)))
  (canonical-base ctx))
#+end_src

#+RESULTS:
#+begin_src text
true
#+end_src
